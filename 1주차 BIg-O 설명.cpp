// Time Complexity : 알고리즘 , Big-O notation
//간단히 시간이 얼마나 소요되는가 

//space complexity : 공간 //표현방식은 time이랑 같음 

//데이터양과 소요시간을 각각 x,y축으로 표현할때 y=x 형태로 가는 함수가 있다 (최댓값찾는 함수가 대표적 예시)
// O(n)--> 데이터 수와 소요시간이 비례한다  

// y=x^2 방향으로 기하급수적으로 늘어나는 함수가 있다면 
//n -> O(n^2)    빅오 

// 알고리즘은 미션을 수행하는 단게

#include <stdio.h>

//int a[5] = { 33,30,60,10,5 }; // 아무생각 없음 자료구조 
 int a[5] = { 1,2,3,4,5 }; //정렬상태 저장하는 자료구조

int main()
{
	printf("최대숫자는 : %d\n", findmax());

	return 0;
}

//정렬된 배열에 대해서는 맨 뒤가 최대 값이니까  n->O(1)  == 데이터양과 상관없이 항상 일정한 시간이 걸린다 

// 정렬되지 않은 배열에 대해서는 데이터 갯수 n에 대해 n-1번만큼 비교하고 실행이 되니 
// n -> O(n-1) 이지만 n이 무한대로 발산을 하면 -1의 개념이 사라지니 이정도 숫자는 n -> O(n) 이라고 표현

// O(1) -> O(log n) -> O(n) -> O(n log n) //여기까지 아주 나이스// -> O(n^2) -> O(n^3) -> O(2^n)//아주 형편없다 

// O(n^2) 예시
// 배열 {2,3,1,5,6} 중 먼저 제일 작은 수 찾기 -> 이미 5번 진행 그후 그거빼고 작은거는 4번 진행 그렇게 3번2번1번.... 
// 등차수열의 합이 되므로 원래는 O(1/2{n(n+1)}) 이 되지만 
// 빅오는 정확한 수치가 아니므로 2분의 1날려주고 n을 무한대로 보내면 n하나는 의미가 없으므로 O(n^2) 으로 쓴다 